#ifndef TENSOR_H
#define TENSOR_H

#include <algorithm>
#include <functional>
#include <vector>
#include <initializer_list>
#include <cassert>
#include "Storage.h"

using std::vector;
using std::initializer_list;

template <class T>
class Tensor
{
public:

    template <bool isConst = true>
    class Iterator
    {
    public:
        typedef typename std::conditional<isConst, const Tensor<T>&, Tensor<T>&>::type ParentType;
        typedef typename std::conditional<isConst, const T&, T&>::type ReferenceType;

        friend class Tensor;
        friend class Iterator<true>;
        
        // // Increment decrement
        Iterator<isConst>& operator++()
        {
            // Update the index (N-ary counter)
            int dim = mIndices.size() - 1;
            mIndices[dim]++;
            while (dim > 0 && mIndices[dim] >= mParent.mShape[dim])
            {
                mIndices[dim] = 0;
                mIndices[dim - 1]++;
                --dim;
            }

            return *this;
        }

        Iterator<isConst> operator++(int)
        {
            Iterator ret = *this;
            ++(*this);
            return ret;
        }

        // Comparison
        bool operator==(const Iterator<isConst>& other)
        {
            return mIndices == other.mIndices;
        }

        bool operator!=(const Iterator<isConst>& other)
        {
            return !(*this == other);
        }
        
        // Assignment
        Iterator<isConst>& operator=(const Iterator<isConst>& other)
        {
            mIndices = other.mIndices;
            return *this;
        }

        // Dereferencing
        ReferenceType operator*()
        {
            return mParent(mIndices.begin(), mIndices.end());
        }

    private:
        ParentType mParent;
        vector<size_t> mIndices;

        Iterator(ParentType parent) : 
            mParent(parent), mIndices(parent.rank()) {}

        Iterator(ParentType parent, vector<size_t> indices) : 
            mParent(parent), mIndices(indices) {}

        // Create a non-const iterator from a const iterator
        Iterator(const Iterator<false>& other) : 
            mParent(other.mParent), mIndices(other.mIndices) {}
    };

    typedef Iterator<false> iterator;
    typedef Iterator<true> const_iterator;

    // Default constructor. Creates an empty Tensor
    // with a new storage.
    Tensor();

    // Creates a new Tensor that references the same
    // storage as 'other'. The shape, stride, and offset
    // will all match 'other'.
    Tensor(const Tensor<T>& other);

    // Create a new Tensor with the given shape/stride. 
    // New storage will be allocated. Initializer lists allow
    // for syntax like this: "Tensor<double>({3, 5})", while
    // iterators allow for other containers to be used instead.
    Tensor(std::initializer_list<size_t> shape);
    Tensor(std::initializer_list<size_t> shape, 
        std::initializer_list<size_t> stride);

    template <class InputIt>
    Tensor(InputIt shapeBegin, InputIt shapeEnd);
    template <class InputIt>
    Tensor(InputIt shapeBegin, InputIt shapeEnd, 
        InputIt strideBegin, InputIt strideEnd);

    // Create a new Tensor using the given storage. The storage
    // offset, shape, and stride can all be provided or ignored.
    // When only the storage is provided, a 1D tensor is created.
    //
    // As with the other constructors, either initializer lists 
    // or iterator pairs may be used to provide values.
    Tensor(Storage<T>& storage, const size_t offset = 0);
    Tensor(Storage<T>& storage, std::initializer_list<size_t> shape,
        const size_t offset = 0);
    Tensor(Storage<T>& storage, 
        std::initializer_list<size_t> shape,
        std::initializer_list<size_t> stride,
        const size_t offset = 0);

    template <class InputIt>
    Tensor(Storage<T>& storage, InputIt shapeBegin, 
        InputIt shapeEnd, const size_t offset = 0);
    template <class InputIt>
    Tensor(Storage<T>& storage,
        InputIt shapeBegin, InputIt shapeEnd,
        InputIt strideBegin, InputIt strideEnd, 
        const size_t offset = 0);
    
    // Element Access
    const T& operator()(initializer_list<size_t> indices) const;
    T& operator()(initializer_list<size_t> indices);

    template <class InputIt>
    const T& operator()(InputIt indicesBegin, InputIt indicesEnd) const;
    template <class InputIt>
    T& operator()(InputIt indicesBegin, InputIt indicesEnd);

    // Iterators
    iterator begin();
    const_iterator begin() const;
    iterator end();
    const_iterator end() const;

    // Create a new Tensor containing the same information as
    // this object. New memory will be allocated. The template
    // parameter U controls the destination type. If the
    // destination type does not match the original type, the
    // appropriate type conversion will be used on each element
    // of the original Tensor object (e.g. casting from
    // Tensor<double> to Tensor<int>). Note that it is
    // possible for a type conversion to lose information.
    template <class U>
    Tensor<U> clone() const;

    // Copy the given value into every cell of the Tensor. 
    // Returns *this so operations may be chained if desired.
    Tensor<T>& fill(const T& value);

    // Applies the given function (anything with a () operator
    // that takes a T and returns a T) to this tensor. Returns
    // *this so operations may be chained if desired.
    template <class Function>
    Tensor<T>& apply(Function&& f);

    // Getters
    Storage<T>&    storage()                      { return mStorage;      }
    size_t         shape(const size_t dim)  const { return mShape[dim];   }
    vector<size_t> shape()                  const { return mShape;        }
    size_t         rank()                   const { return mShape.size(); }
    size_t         stride(const size_t dim) const { return mStride[dim];  }
    vector<size_t> stride()                 const { return mStride;       }
    size_t         size()                   const { return mNumElements;  }

private:
    Storage<T> mStorage;
    vector<size_t> mShape;
    vector<size_t> mStride;
    size_t mNumElements;

    // Helper functions
    void calculateOptimalStride();
};

//-------------------------------------------------------------//
template <class T>
Tensor<T>::Tensor() : 
    mNumElements(0) 
{}

template <class T>
Tensor<T>::Tensor(const Tensor<T>& other) :
    mStorage(other.mStorage), 
    mShape(other.mShape),
    mStride(other.mStride), 
    mNumElements(other.mNumElements)
{}

template <class T>
Tensor<T>::Tensor(std::initializer_list<size_t> shape) :
    Tensor<T>(shape.begin(), shape.end())
{}

template <class T>
Tensor<T>::Tensor(std::initializer_list<size_t> shape, 
    std::initializer_list<size_t> stride) :
    Tensor<T>(shape.begin(), shape.end(), stride.begin(), stride.end())
{}

template <class T>
template <class InputIt>
Tensor<T>::Tensor(InputIt shapeBegin, InputIt shapeEnd)
{
    // Save the shape
    mShape.insert(mShape.begin(), shapeBegin, shapeEnd);

    // Calculate the stride
    calculateOptimalStride();

    // Figure out how many cells there should be
    mNumElements = std::accumulate(mShape.begin(), mShape.end(), 1, std::multiplies<size_t>());

    // Make sure the storage is the correct size
    mStorage.resize(mNumElements);
}

template <class T>
template <class InputIt>
Tensor<T>::Tensor(InputIt shapeBegin, InputIt shapeEnd, 
    InputIt strideBegin, InputIt strideEnd)
{
    bool condition = (std::distance(shapeBegin, shapeEnd) == std::distance(strideBegin, strideEnd));
    assert(("Shape and stride must have the same # of dimensions.", 
        condition));

    // Save the shape
    mShape.insert(mShape.begin(), shapeBegin, shapeEnd);

    // Save the stride
    mStride.insert(mStride.begin(), strideBegin, strideEnd);

    // Figure out how many cells there should be
    mNumElements = std::accumulate(mShape.begin(), mShape.end(), 1, std::multiplies<size_t>());

    // Make sure the storage is the correct size
    mStorage.resize(mNumElements);
}

template <class T>
Tensor<T>::Tensor(Storage<T>& storage, 
    const size_t offset) :
    mStorage(storage, offset), 
    mShape({mStorage.size()}), 
    mStride({1}), 
    mNumElements(mStorage.size())
{}

template <class T>
Tensor<T>::Tensor(Storage<T>& storage, 
    std::initializer_list<size_t> shape, 
    const size_t offset) :
    Tensor<T>(storage, shape.begin(), shape.end(), offset)
{}

template <class T>
Tensor<T>::Tensor(Storage<T>& storage,
    std::initializer_list<size_t> shape,
    std::initializer_list<size_t> stride,
    const size_t offset) :
    Tensor<T>(storage, shape.begin(), shape.end(),
        stride.begin(), stride.end(), offset)
{}

template <class T>
template <class InputIt>
Tensor<T>::Tensor(Storage<T>& storage, InputIt shapeBegin, 
    InputIt shapeEnd, const size_t offset) :
    mStorage(storage, offset)
{
    // Save the shape
    mShape.insert(mShape.begin(), shapeBegin, shapeEnd);

    // Calculate the stride
    calculateOptimalStride();

    // Figure out how many cells there should be
    mNumElements = std::accumulate(mShape.begin(), mShape.end(), 1, std::multiplies<size_t>());
}

template <class T>
template <class InputIt>
Tensor<T>::Tensor(Storage<T>& storage,
    InputIt shapeBegin, InputIt shapeEnd,
    InputIt strideBegin, InputIt strideEnd, 
    const size_t offset) :
    mStorage(storage, offset)
{
    bool condition = (std::distance(shapeBegin, shapeEnd) == std::distance(strideBegin, strideEnd));
    assert(("Shape and stride must have the same # of dimensions.", condition));

    // Save the shape
    mShape.insert(mShape.begin(), shapeBegin, shapeEnd);

    // Save the stride
    mStride.insert(mStride.begin(), strideBegin, strideEnd);

    // Figure out how many cells there should be
    mNumElements = std::accumulate(mShape.begin(), mShape.end(), 1, std::multiplies<size_t>());
}

template <class T>
void Tensor<T>::calculateOptimalStride()
{
    mStride.clear();
    mStride.resize(mShape.size());
    size_t multiplier = 1;
    size_t index      = mStride.size() - 1;
    for (auto shapeIt = mShape.end() - 1; shapeIt != mShape.begin() - 1; --shapeIt)
    {
        mStride[index--] = multiplier;
        multiplier *= (*shapeIt);
    }
}

template <class T>
const T& Tensor<T>::operator()(initializer_list<size_t> indices) const
{
    return (*this)(indices.begin(), indices.end());
}

template <class T>
T& Tensor<T>::operator()(initializer_list<size_t> indices)
{
    return (*this)(indices.begin(), indices.end());
}

template <class T>
template <class InputIt>
const T& Tensor<T>::operator()(InputIt indicesBegin, InputIt indicesEnd) const
{
    // Guarantee the ranks match
    const bool ranksMatch = std::distance(indicesBegin, indicesEnd) == (int)rank();
    assert(("Number of indices given does not match tensor shape.", ranksMatch));

    size_t index   = 0;
    auto strideIt  = mStride.begin();

    for (auto& indicesIt = indicesBegin; indicesIt != indicesEnd; ++indicesIt)
        index += (*indicesIt) * (*strideIt++);
 
    return mStorage[index];
}

template <class T>
template <class InputIt>
T& Tensor<T>::operator()(InputIt indicesBegin, InputIt indicesEnd)
{
    return const_cast<T&>
    (
        static_cast<const Tensor<T>*>(this)->operator()(indicesBegin, indicesEnd)
    );
}

template <class T>
typename Tensor<T>::iterator Tensor<T>::begin()
{
    return Tensor<T>::iterator(*this);
}

template <class T>
typename Tensor<T>::const_iterator Tensor<T>::begin() const
{
    return Tensor<T>::const_iterator(*this);
}

template <class T>
typename Tensor<T>::iterator Tensor<T>::end()
{
    vector<size_t> indices(rank());
    indices[0] = mShape[0];
    return Tensor<T>::iterator(*this, indices);
}

template <class T>
typename Tensor<T>::const_iterator Tensor<T>::end() const
{
    vector<size_t> indices(rank());
    indices[0] = mShape[0];
    return Tensor<T>::const_iterator(*this, indices);
}

template <class T>
template <class U>
Tensor<U> Tensor<T>::clone() const
{
    // Create new contiguous storage for the clone
    Storage<U> storage(mNumElements);

    // Fill the storage with the elements from this tensor
    size_t i = 0;
    for (auto& elem : *this)
        storage[i++] = U(elem);

    // Use the source's shape, but let the stride be inferred
    return Tensor<U>(storage, mShape.begin(), mShape.end());
}

template <class T>
Tensor<T>& Tensor<T>::fill(const T& value)
{
    // if (contiguous)
    //     std::fill(mStorage.begin(), mStorage.begin() + mNumElements, value);
    // else
    {
        for (auto& elem : *this)
            elem = value;
    }

    return *this;
}

template <class T>
template <class Function>
Tensor<T>& Tensor<T>::apply(Function&& f)
{
    for (auto& elem : *this)
        elem = f(elem);
    return *this;
}

// // Common implementation for both versions of reshape() above
// template <class InputIt>
// void reshape(InputIt begin, InputIt end)
// {
    // // Calculate size of new shape
    // size_t numElements = 1;
    // for (auto it = begin; it != end; ++it)
        // numElements *= (*it);

    // if (numElements != 0)
    // {
        // // Ensure everything is OK
        // assert(("Number of elements cannot be changed with a reshape.",
            // numElements == mNumElements));

        // mShape.clear();
        // mShape.insert(mShape.begin(), begin, end);
    // }

    // // Deal with missing values
    // else
    // {
        // vector<size_t> values(begin, end);
        // size_t partialProduct = 1;
        // int count             = 0;
        // size_t zeroIndex      = 0;
        // for (size_t i = 0; i < values.size(); ++i)
        // {
            // if (values[i] != 0)
                // partialProduct *= values[i];
            // else
            // {
                // ++count;
                // zeroIndex = i;
            // }
        // }

        // // We can't deal with 2 or more 0 elements
        // assert(("At most 1 dimension can be inferred.", count <= 1));

        // // It has to be possible to fill in the missing value
        // assert(("Not possible to infer dimension.",
            // mNumElements % partialProduct == 0));

        // values[zeroIndex] = mNumElements / partialProduct;
        // mShape.clear();
        // mShape.insert(mShape.begin(), values.begin(), values.end());
    // }
// }

// // Common implementation for both versions of resize() above
// template <class InputIt>
// void resize(InputIt begin, InputIt end)
// {
    // mNumElements = 1;
    // for (auto it = begin; it != end; ++it)
        // mNumElements *= (*it);

    // // We do not allow partial declaration of the shape
    // assert(("Partial declaration not allowed in resize().",
        // mNumElements != 0));

    // mShape.clear();
    // mShape.insert(mShape.begin(), begin, end);

    // // Calculate the stride
    // mStride.resize(mShape.size());
    // size_t multiplier = 1;
    // size_t index      = mStride.size() - 1;
    // for (auto shapeIt = mShape.end() - 1; shapeIt != mShape.begin() - 1; --shapeIt)
    // {
        // mStride[index--] = multiplier;
        // multiplier *= (*shapeIt);
    // }

    // // Reset the offset
    // mOffset = 0;
// }

#endif
